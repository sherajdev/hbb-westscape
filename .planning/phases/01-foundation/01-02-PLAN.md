---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - convex/schema.ts
  - convex/users.ts
  - convex/businesses.ts
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "Database schema exists for users and businesses tables"
    - "User record is created automatically on first authentication"
    - "User attempting to create a second business receives an error"
    - "Business is linked to owner via ownerId foreign key"
  artifacts:
    - path: "convex/schema.ts"
      provides: "Database schema with users and businesses tables"
      contains: "defineTable"
      min_lines: 20
    - path: "convex/users.ts"
      provides: "User creation and lookup functions"
      exports: ["createOrGetUser", "getCurrentUser"]
    - path: "convex/businesses.ts"
      provides: "Business CRUD with one-per-user constraint"
      exports: ["createBusiness", "getMyBusiness"]
  key_links:
    - from: "convex/businesses.ts"
      to: "convex/schema.ts"
      via: "uses users table for ownership"
      pattern: "v.id\\(\"users\"\\)"
    - from: "convex/businesses.ts"
      to: "ctx.db.query"
      via: "indexed query for constraint check"
      pattern: "withIndex.*by_owner"
    - from: "convex/users.ts"
      to: "ctx.auth.getUserIdentity"
      via: "Clerk identity lookup"
      pattern: "getUserIdentity"
---

<objective>
Define the Convex database schema for users and businesses, implement user creation on first auth, and enforce the one-business-per-user constraint.

Purpose: Establish the data layer that supports all business registration and management features. The constraint enforcement is critical for the business model.

Output: Working database schema with users/businesses tables, automatic user creation on auth, and tested one-business-per-user constraint.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

Key patterns from research:
- Schema-first development with Convex validators
- One-business-per-user via indexed query with `.withIndex("by_owner")`
- User creation pattern: check existing by clerkId, create if not found
- Always await ctx.db operations (no floating promises)
- Use v.optional() for nullable fields
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define database schema for users and businesses</name>
  <files>
    convex/schema.ts
  </files>
  <action>
    Replace the placeholder schema with the full schema definition:

    ```typescript
    // convex/schema.ts
    import { defineSchema, defineTable } from "convex/server";
    import { v } from "convex/values";

    export default defineSchema({
      users: defineTable({
        clerkId: v.string(),
        email: v.string(),
        name: v.string(),
        createdAt: v.number(),
      })
        .index("by_clerk_id", ["clerkId"])
        .index("by_email", ["email"]),

      businesses: defineTable({
        ownerId: v.id("users"),
        name: v.string(),
        category: v.union(
          v.literal("Food"),
          v.literal("Beauty"),
          v.literal("Fusion"),
          v.literal("Services")
        ),
        description: v.string(),
        shortDescription: v.optional(v.string()),
        address: v.string(),
        status: v.union(
          v.literal("draft"),
          v.literal("pending"),
          v.literal("approved"),
          v.literal("rejected")
        ),
        // Contact links - will be expanded in Phase 3
        contactPhone: v.optional(v.string()),
        contactWhatsApp: v.optional(v.string()),
        contactInstagram: v.optional(v.string()),
        contactTikTok: v.optional(v.string()),
        contactFacebook: v.optional(v.string()),
        contactCarousell: v.optional(v.string()),
        contactWebsite: v.optional(v.string()),
        // Media - will be expanded in Phase 3
        imageStorageIds: v.optional(v.array(v.id("_storage"))),
        videoStorageId: v.optional(v.id("_storage")),
        // Timestamps
        createdAt: v.number(),
        updatedAt: v.number(),
        approvedAt: v.optional(v.number()),
        rejectedAt: v.optional(v.number()),
        rejectionReason: v.optional(v.string()),
      })
        .index("by_owner", ["ownerId"])
        .index("by_status", ["status"])
        .index("by_category", ["category"])
        .index("by_address", ["address"]),
    });
    ```

    Key design decisions:
    - `by_owner` index enables efficient one-per-user constraint check
    - `by_status` index for admin queries (pending businesses)
    - `by_category` index for directory filtering
    - `by_address` index for future address uniqueness (manual verification for v1)
    - Contact fields are optional - minimum validation happens in mutation logic
    - Status uses lowercase literals for consistency

    Run `npx convex dev` to push schema changes.
  </action>
  <verify>
    - `npx convex dev` completes without schema errors
    - Convex dashboard shows users and businesses tables
    - Tables have correct indexes visible in dashboard
  </verify>
  <done>Schema deployed with users and businesses tables, all required indexes created</done>
</task>

<task type="auto">
  <name>Task 2: Implement user creation and one-business-per-user constraint</name>
  <files>
    convex/users.ts
    convex/businesses.ts
  </files>
  <action>
    1. Update convex/users.ts with user management functions:

    ```typescript
    // convex/users.ts
    import { mutation, query } from "./_generated/server";
    import { v } from "convex/values";

    // Create user on first auth or return existing
    export const createOrGetUser = mutation({
      args: {},
      handler: async (ctx) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Unauthenticated");
        }

        // Check if user already exists
        const existing = await ctx.db
          .query("users")
          .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
          .unique();

        if (existing) {
          return existing._id;
        }

        // Create new user
        const userId = await ctx.db.insert("users", {
          clerkId: identity.subject,
          email: identity.email ?? "",
          name: identity.name ?? "User",
          createdAt: Date.now(),
        });

        return userId;
      },
    });

    // Get current authenticated user
    export const getCurrentUser = query({
      args: {},
      handler: async (ctx) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          return null;
        }

        return await ctx.db
          .query("users")
          .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
          .unique();
      },
    });

    // Query version of auth status (updated from Plan 01)
    export const getAuthStatus = query({
      args: {},
      handler: async (ctx) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          return { authenticated: false, user: null };
        }

        const user = await ctx.db
          .query("users")
          .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
          .unique();

        return {
          authenticated: true,
          user: user
            ? {
                id: user._id,
                clerkId: user.clerkId,
                email: user.email,
                name: user.name,
              }
            : null,
        };
      },
    });
    ```

    2. Create convex/businesses.ts with constraint enforcement:

    ```typescript
    // convex/businesses.ts
    import { mutation, query } from "./_generated/server";
    import { v } from "convex/values";

    // Create a new business (enforces one-per-user)
    export const createBusiness = mutation({
      args: {
        name: v.string(),
        category: v.union(
          v.literal("Food"),
          v.literal("Beauty"),
          v.literal("Fusion"),
          v.literal("Services")
        ),
        description: v.string(),
        address: v.string(),
      },
      handler: async (ctx, args) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Unauthenticated");
        }

        // Get user record
        const user = await ctx.db
          .query("users")
          .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
          .unique();

        if (!user) {
          throw new Error("User not found. Please refresh and try again.");
        }

        // CRITICAL: Check if user already has a business (one-per-user constraint)
        const existingBusiness = await ctx.db
          .query("businesses")
          .withIndex("by_owner", (q) => q.eq("ownerId", user._id))
          .unique();

        if (existingBusiness) {
          throw new Error("You already have a registered business. Each user can only register one business.");
        }

        // Create the business
        const now = Date.now();
        const businessId = await ctx.db.insert("businesses", {
          ownerId: user._id,
          name: args.name,
          category: args.category,
          description: args.description,
          shortDescription: args.description.substring(0, 100),
          address: args.address,
          status: "draft",
          createdAt: now,
          updatedAt: now,
        });

        return businessId;
      },
    });

    // Get the current user's business
    export const getMyBusiness = query({
      args: {},
      handler: async (ctx) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          return null;
        }

        const user = await ctx.db
          .query("users")
          .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
          .unique();

        if (!user) {
          return null;
        }

        return await ctx.db
          .query("businesses")
          .withIndex("by_owner", (q) => q.eq("ownerId", user._id))
          .unique();
      },
    });

    // Check if user can create a business
    export const canCreateBusiness = query({
      args: {},
      handler: async (ctx) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          return { canCreate: false, reason: "Not authenticated" };
        }

        const user = await ctx.db
          .query("users")
          .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
          .unique();

        if (!user) {
          return { canCreate: false, reason: "User not found" };
        }

        const existingBusiness = await ctx.db
          .query("businesses")
          .withIndex("by_owner", (q) => q.eq("ownerId", user._id))
          .unique();

        if (existingBusiness) {
          return { canCreate: false, reason: "Already has a business" };
        }

        return { canCreate: true, reason: null };
      },
    });
    ```

    3. Run `npx convex dev` to deploy functions.
  </action>
  <verify>
    - `npx convex dev` deploys without errors
    - Convex dashboard shows users.ts and businesses.ts functions
    - Functions are listed: createOrGetUser, getCurrentUser, getAuthStatus, createBusiness, getMyBusiness, canCreateBusiness
  </verify>
  <done>User and business functions deployed with one-per-user constraint logic implemented</done>
</task>

<task type="auto">
  <name>Task 3: Test constraint enforcement end-to-end</name>
  <files>
    app/page.tsx
  </files>
  <action>
    1. Update app/page.tsx to test the full flow including constraint:

    ```typescript
    "use client";
    import { useQuery, useMutation } from "convex/react";
    import { useConvexAuth } from "convex/react";
    import { api } from "@/convex/_generated/api";
    import { SignInButton, SignOutButton, useUser } from "@clerk/nextjs";
    import { useState, useEffect } from "react";

    export default function Home() {
      const { isLoading, isAuthenticated } = useConvexAuth();
      const { user: clerkUser } = useUser();
      const [error, setError] = useState<string | null>(null);
      const [success, setSuccess] = useState<string | null>(null);

      // Queries
      const authStatus = useQuery(
        api.users.getAuthStatus,
        isAuthenticated ? {} : "skip"
      );
      const myBusiness = useQuery(
        api.businesses.getMyBusiness,
        isAuthenticated ? {} : "skip"
      );
      const canCreate = useQuery(
        api.businesses.canCreateBusiness,
        isAuthenticated ? {} : "skip"
      );

      // Mutations
      const createOrGetUser = useMutation(api.users.createOrGetUser);
      const createBusiness = useMutation(api.businesses.createBusiness);

      // Create user record on first auth
      useEffect(() => {
        if (isAuthenticated && authStatus?.authenticated && !authStatus?.user?.id) {
          createOrGetUser().catch(console.error);
        }
      }, [isAuthenticated, authStatus, createOrGetUser]);

      const handleCreateBusiness = async () => {
        setError(null);
        setSuccess(null);
        try {
          await createBusiness({
            name: "Test Business " + Date.now(),
            category: "Food",
            description: "A test business for verifying the constraint",
            address: "123 Test Street, WestScape",
          });
          setSuccess("Business created successfully!");
        } catch (e: any) {
          setError(e.message);
        }
      };

      const handleTestConstraint = async () => {
        setError(null);
        setSuccess(null);
        try {
          await createBusiness({
            name: "Second Business Attempt",
            category: "Beauty",
            description: "This should fail",
            address: "456 Another Street",
          });
          setSuccess("Business created (unexpected!)");
        } catch (e: any) {
          setError(e.message);
          if (e.message.includes("already have a registered business")) {
            setSuccess("Constraint working correctly!");
          }
        }
      };

      if (isLoading) {
        return <div className="p-8">Loading...</div>;
      }

      return (
        <main className="p-8 max-w-2xl mx-auto">
          <h1 className="text-2xl font-bold mb-4">HBB@WestScape - Foundation Test</h1>

          {!isAuthenticated ? (
            <div>
              <p className="mb-4">Please sign in to test the foundation</p>
              <SignInButton mode="modal">
                <button className="bg-blue-500 text-white px-4 py-2 rounded">
                  Sign In
                </button>
              </SignInButton>
            </div>
          ) : (
            <div className="space-y-6">
              {/* Auth Status */}
              <section className="border p-4 rounded">
                <h2 className="font-semibold mb-2">Auth Status</h2>
                <p>Clerk: {clerkUser?.firstName} ({clerkUser?.emailAddresses[0]?.emailAddress})</p>
                <p>Convex User ID: {authStatus?.user?.id ?? "Not created yet"}</p>
                <SignOutButton>
                  <button className="mt-2 text-sm text-gray-500 underline">Sign Out</button>
                </SignOutButton>
              </section>

              {/* Business Status */}
              <section className="border p-4 rounded">
                <h2 className="font-semibold mb-2">Business Status</h2>
                {myBusiness ? (
                  <div>
                    <p className="text-green-600">You have a business registered:</p>
                    <p><strong>Name:</strong> {myBusiness.name}</p>
                    <p><strong>Category:</strong> {myBusiness.category}</p>
                    <p><strong>Status:</strong> {myBusiness.status}</p>
                  </div>
                ) : (
                  <p>No business registered yet</p>
                )}
                <p className="mt-2 text-sm">
                  Can create: {canCreate?.canCreate ? "Yes" : `No (${canCreate?.reason})`}
                </p>
              </section>

              {/* Test Actions */}
              <section className="border p-4 rounded">
                <h2 className="font-semibold mb-2">Test Actions</h2>
                <div className="space-x-2">
                  <button
                    onClick={handleCreateBusiness}
                    disabled={!canCreate?.canCreate}
                    className="bg-green-500 text-white px-4 py-2 rounded disabled:opacity-50"
                  >
                    Create Business
                  </button>
                  <button
                    onClick={handleTestConstraint}
                    className="bg-orange-500 text-white px-4 py-2 rounded"
                  >
                    Test Constraint (Try Second)
                  </button>
                </div>
                {error && <p className="mt-2 text-red-600">Error: {error}</p>}
                {success && <p className="mt-2 text-green-600">{success}</p>}
              </section>

              {/* Success Criteria */}
              <section className="border p-4 rounded bg-gray-50">
                <h2 className="font-semibold mb-2">Phase 1 Success Criteria</h2>
                <ul className="space-y-1 text-sm">
                  <li className={authStatus?.authenticated ? "text-green-600" : "text-gray-400"}>
                    {authStatus?.authenticated ? "✓" : "○"} User can sign up and log in via Clerk
                  </li>
                  <li className={authStatus?.user?.id ? "text-green-600" : "text-gray-400"}>
                    {authStatus?.user?.id ? "✓" : "○"} User record created in Convex
                  </li>
                  <li className="text-green-600">
                    ✓ Database schema exists for users and businesses
                  </li>
                  <li className={myBusiness || (error?.includes("already have")) ? "text-green-600" : "text-gray-400"}>
                    {myBusiness || (error?.includes("already have")) ? "✓" : "○"} One-business-per-user constraint works
                  </li>
                </ul>
              </section>
            </div>
          )}
        </main>
      );
    }
    ```

    2. Test sequence:
       a. Sign in with a test account
       b. Verify user record appears in Convex (check dashboard or UI)
       c. Click "Create Business" - should succeed
       d. Verify business appears in Business Status section
       e. Click "Test Constraint (Try Second)" - should fail with constraint error
       f. Verify "Constraint working correctly!" message appears
       g. Verify "Can create: No (Already has a business)" shows

    3. Optional: Test with a second Clerk account to verify independent users can each create one business
  </action>
  <verify>
    - First business creation succeeds
    - Second business creation fails with "already have a registered business" error
    - canCreateBusiness query returns false after first business created
    - UI shows all success criteria as checked
    - Convex dashboard shows 1 user and 1 business record
  </verify>
  <done>One-business-per-user constraint verified working, all Phase 1 success criteria met</done>
</task>

</tasks>

<verification>
Phase 1 Plan 02 is complete when:
1. Schema deployed with users and businesses tables (verify in Convex dashboard)
2. User record created automatically on first authentication
3. First business creation succeeds
4. Second business creation fails with clear error message
5. canCreateBusiness returns appropriate status
6. All Phase 1 success criteria checkboxes can be checked in the test UI
</verification>

<success_criteria>
- Database schema exists for businesses, users, and their relationships
- User record created on first auth
- System enforces one business per user constraint
- Constraint error message is user-friendly
- Foundation ready for Phase 2 (Public Directory)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` documenting:
- Schema design decisions
- Constraint implementation details
- Test results
- Any issues encountered
</output>
